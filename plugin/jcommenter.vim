" File: jcommenter.vim
" Summary: Functions for documenting java-code
" Author: Kalle Björklid <bjorklid@st.jyu.fi>
" Last Modified: 11.8.2001
" Version: 1.0 
" Modifications:
"  1.0 : Did a complete rewrite of the script-code (this is the main reason
"            for the version-number leap)
"        A separate config-file, which should be modified to reflect the
"            user's preferences
"        More variables for better customization
"        Due to the rewrite, should now be more robust (allthough new bugs
"            may have been introduced during the process)
"        Cursor movement and auto-start insert mode
"        Better control over the look of the comment templates
"        See installation instructions below (has changed)
"  0.4 : Recognizes now methods that have whitespaces before the '('.
"        The file comments can now be completely redefined (see below for
"            instructions) without editing the script.
"        The comment-skeleton for fields is changed from '/**  */ to correspond
"            with the Sun's code conventions:
"            /**
"	          *
"	          */
"  0.3 : Added tag copying
"        Recognizes interfaces (same as classes)
"  0.21: Improved the java-method recognition.
"  0.2 : initial public release.
" 
" Tested on Vim 6.0ap on Win32
"
" Description: Functions for automatically generating JavaDoc compatible
" documentation for java source-files.
" The JCommentWriter() can produce four kinds of comments depending on the
" current line/range.
" - File comments. When the JCommentWriter()-function is called on the first
"   line of the file, a template for file comments is created. It looks like
"   this:
"
"       /*  Filename : <name of current buffer>
"        *  Author   : <author>
"        *  Summary  :
"        *  Version  :
"        *  Created  : <current system time>
"        */
"
"   The file name and 'Created'-date are automatically filled. The author-
"   field is filled with the contents of 'b:jcommenter_file_author'-variable.
"   The automated date insertion can be prevented by defining the
"   'b:jcommenter_file_noautotime'-variable.
"   You can redefine completely the file comments-writer-function. See the
"   configuration script for more info
"
" - Class comments. When the JCommentWriter()-function is called on the
"   header of a class, a template for class comments is created. It looks like
"   this:
"
" 	/**
"	 *
"	 * @author <author>
"	 * @version <version> 
"	 */
"	public class ClassName { ...
"
"   The @author-field is automatically filled with the contents of the
"   'b:jcommenter_class_author'-variable.
"   The @version-field is automatically filled with the contents of the
"   'b:jcommenter_class_def_version'-variable
" - Method comments. JCommentWriter()-function automatically generates
"   the template for method comments if it is called on a header of a
"   method. The JavaDoc-tags are automatically generated by detecting
"   the parameter names, return value and exceptions that are declared
"   in the header of the method. An example:
"
"	/**
"	 *
"	 * @param numbers
"	 * @param str
"	 * @return 
" 	 * @throws IOException
"	 * @throws NumberFormatException
"	 */
"	public String [] method(Integer[] numbers, String str) throws 
"				IOException, NumberFormatException { 
"
"   Note: since the method header is on two lines, you need to specify
"   the range (include everything before the '{', or ';' if the method is
"   abstract). This can be done simply with line-wise visual selection.
" - Field comments. Appends this above the field declaration:
"        /**
"         *
"         */
" - When executed on an existing JavaDoc tag, copy that tag under that line.
"   For example, when executed on the following line:
"      * @throws IOException If cannot read file
"   the result is:
"      * @throws IOException If cannot read file
"      * @throws
"   Not that life changing, but quite nice when you want to document those
"   RuntimeExceptions, or need to add another paramter.
"
" Installation:
" 
" 1. Edit the jcommenter_config.vim-file. The config file is commented, so I
"    won't explain the options here).
" 2. Put something like
"      autocmd FileType java source $VIM/jcommenter_config.vim
"      aurocmd FileType java source $VIM/macros/jcommenter.vim
"    to your vimrc
"
" Usage:
" If you didn't change the mapping specified in the config-file, you can
" can trigger the comment-generation by pressing Alt-c (or "Meta-c"). As
" described above, the cursor must be on the first line or on the same line
" as the method/class/attribute declaration in order to achieve something 
" useful. If the declaration extends to several lines, the range must be 
" specified.  Range should include everything from the declaration that 
" comes before the '{' or ';'. Everything after either of those characters 
" is ignored, so linewise selection is a handy way to do this (<shift-v>)
"
" Notes: 
"  - If a method name starts with an uppercase letter, it is handled as a
"    constructor (no @return-tag is generated)
"
" TODO: better recognition for constructors
" TODO: support for the umlaut-chars etc. that can be also used in java
" TODO: Inner classes/interfaces...
" TODO: Recognise and update old method comments.
" TODO: Add an option to use @exception instead of @throws (for backward
"       compatibility)
" TODO: sort exceptions alphabetically (see
"       http://java.sun.com/j2se/javadoc/writingdoccomments/index.html)
" TODO: comment the script
"
" Comments:
" Send any comments or bugreports to bjorklid@st.jyu.fi
" Happy coding!  ;-)
"=====================================================================

" varible that tells what is put before the written string when using
" the AppendStr-function.
let s:indent = ''

" The string that includes the text of the line on which the commenter
" was called, or the whole range.
let s:combinedString = ''

let s:rangeStart = 1
let s:rangeEnd = 1

let s:defaultMethodDescriptionSpace = 1
let s:defaultFieldDescriptionSpace = 1
let s:defaultClassDescriptionSpace = 1

let s:linesAppended = 0
" ===================================================
" Public functions
" ===================================================

function! JCommentWriter() range
  let s:rangeStart = a:firstline
  let s:rangeEnd = a:lastline
  let s:combinedString = s:GetCombinedString(s:rangeStart, s:rangeEnd)

  if s:IsFileComments()
    call s:WriteFileComments()
  elseif s:IsMethod()
    call s:WriteMethodComments()
  elseif s:IsClass()
    call s:WriteClassComments()
  elseif s:IsCommentTag()
    call s:WriteCopyOfTag()
  elseif s:IsVariable()
    call s:WriteFieldComments()
  endif
endfunction

" ===================================================
" Functions for writing the comments 
" ===================================================

function! s:WriteMethodComments()
  call s:ResolveMethodParams(s:combinedString)
  let s:appendPos = s:rangeStart - 1
  let s:indent = s:method_indent
  let s:linesAppended = 0

  if exists("b:jcommenter_method_description_space")
    let descriptionSpace = b:jcommenter_method_description_space
  else
    let descriptionSpace = s:defaultMethodDescriptionSpace
  endif
  
  call s:AppendStr('/** ')

  let param = s:GetNextParameterName()
  let exception = s:GetNextThrowName()

  if param == '' && s:method_returnValue == '' && exception == '' && exists("b:jcommenter_smart_method_description_spacing") && b:jcommenter_smart_method_description_spacing
    call s:AppendStars(1)
  else 
    call s:AppendStars(descriptionSpace)
  endif

  while param != ''
    call s:AppendStr(' * @param ' . param . ' ')
    let param = s:GetNextParameterName()
  endwhile

  if s:method_returnValue != ''
    call s:AppendStr(' * @return ')
  endif

  while exception != ''
    call s:AppendStr(' * @throws ' . exception . ' ')
    let exception = s:GetNextThrowName()
  endwhile

  call s:AppendStr(' */')

  call s:MoveCursor()

endfunction

function! s:WriteCopyOfTag()
  let tagName = substitute(s:combinedString, '.*\*\(\s*@\S\+\).*', '\1', '')
  let s:indent = s:GetIndentation(s:combinedString)
  let s:appendPos = s:rangeStart
  call s:AppendStr('*' . tagName . ' ')
  call s:MoveCursor()
endfunction

function! s:WriteFileComments()
  let author = ''
  if exists("*JCommenter_OwnFileComments")
    call JCommenter_OwnFileComments()
    return
  endif
  if exists("b:jcommenter_file_author")
    let author = b:jcommenter_file_author
  endif

  if exists("b:jcommenter_file_noautotime") && b:jcommenter_file_noautotime
    let created = ''
  else
    let created = strftime("%c")
  endif

  let s:appendPos = s:rangeStart - 1
  let s:indent    = ''
  call s:AppendStr('/* file name  : ' . bufname("%"))
  if exists("b:jcommenter_file_author")
    call s:AppendStr(' * authors    : ' . author)
  endif
  call s:AppendStr(' * created    : ' . created)
  if exists("b:jcommenter_file_copyright")
    call s:AppendStr(' * copyright  : ' . b:jcommenter_file_copyright)
  endif
  call s:AppendStr(' *')
  call s:AppendStr(' * modifications:')
  call s:AppendStr(' *')
  call s:AppendStr(' */')
endfunction  

function! s:WriteFieldComments()
  let s:appendPos = s:rangeStart - 1
  let s:indent = s:GetIndentation(s:combinedString)
  if exists("b:jcommenter_field_description_space")
    let descriptionSpace = b:jcommenter_field_description_space
  else
    let descriptionSpace = s:defaultFieldDescriptionSpace
  endif

  if descriptionSpace == -1
    call s:AppendStr('/**  */')
    if exists("b:jcommenter_move_cursor")
      normal k$hh
      if exists("b:jcommenter_autostart_insert_mode")
        startinsert
      endif
    endif
  else
    call s:AppendStr('/** ')
    call s:AppendStars(descriptionSpace)
    call s:AppendStr(' */')
    call s:MoveCursor()
  endif

endfunction

function! s:WriteClassComments()
  let s:indent = s:GetIndentation(s:combinedString)

  if exists("b:jcommenter_class_description_space")
    let descriptionSpace = b:jcommenter_class_description_space
  else
    let descriptionSpace = s:defaultFieldDescriptionSpace
  endif

  let s:appendPos = s:rangeStart - 1

  call s:AppendStr('/** ')

  call s:AppendStars(descriptionSpace)

  if exists('b:jcommenter_class_author')
    call s:AppendStr(' * @author ' . b:jcommenter_class_author)
  endif

  if exists('b:jcommenter_class_version')
    call s:AppendStr(' * @version ' . b:jcommenter_class_version)
  endif

  call s:AppendStr(' */')
  call s:MoveCursor()
endfunction

function! Test()
  call s:ResolveMethodParams('    public static int argh(String str, int i) throws Exception1, Exception2 {')
  let s:appendPos = 1
  let s:indent = s:method_indent
  call s:AppendStr(s:method_returnValue)
  call s:AppendStr(s:method_paramList)
  call s:AppendStr(s:method_throwsList)
  let param = s:GetNextParameterName()
  while param != '' 
    call s:AppendStr(param)
    let param = s:GetNextParameterName()
  endwhile

  let exc = s:GetNextThrowName()
  while exc != ''
    call s:AppendStr(exc)
    let exc = s:GetNextThrowName()
  endwhile
endfunction

" ===================================================
" Functions to parse things
" ===================================================


function! s:ResolveMethodParams(methodHeader)
  let methodHeader = a:methodHeader
  let methodHeader = substitute(methodHeader, '^\(.\{-}\)\s*[{;].*', '\1', '')

  let s:appendPos = s:rangeStart - 1
  let s:method_indent = substitute(methodHeader, '^\(\s*\)\S.*', '\1', '')

  let preNameString = substitute(methodHeader, '^\(\(.*\)\s\)' . s:javaname . '\s*(.*', '\1', '')
  let s:method_returnValue = substitute(preNameString, '\(.*\s\|^\)\(' . s:javaname . '\(\s*\[\s*\]\)*\)\s*$', '\2', '')

  if s:method_returnValue == 'void' || s:IsConstructor(methodHeader)
    let s:method_returnValue = ''
  endif

  let s:method_paramList = substitute(methodHeader, '.*(\(.*\)).*', '\1', '')
  let s:method_paramList = s:Trim(s:method_paramList)

  let s:method_throwsList = ''
  if methodHeader =~ ')\s*throws\s'
    let s:method_throwsList = substitute(methodHeader, '.*)\s*throws\s\+\(.\{-}\)\s*$', '\1', '')
  endif
endfunction

function! s:IsConstructor(methodHeader)
  return a:methodHeader =~ '\(^\|\s\)[A-Z][a-zA-Z0-9]*\s*('
endfunction

function! s:GetNextParameterName()
  let result = substitute(s:method_paramList, '.\{-}\s\+\(' . s:javaname . '\)\s*\(,.*\|$\)', '\1', '')
  if s:method_paramList !~ ','
    let s:method_paramList = ''
  else 
     let endIndex = matchend(s:method_paramList, ',\s*')
     let s:method_paramList = strpart(s:method_paramList, endIndex)
  endif
  return result
endfunction!

function! s:GetNextThrowName()
  let result = substitute(s:method_throwsList, '\s*\(' . s:javaname . '\)\s*\(,.*\|$\)', '\1', '')
  if match(s:method_throwsList, ',') == -1
    let s:method_throwsList = ''
  else
    let s:method_throwsList = substitute(s:method_throwsList, '.\{-},\s*\(.*\)', '\1', '')
  endif
  return result
endfunction

" ===================================================
" Functions to determine what is meant to be commented
" ===================================================

" pattern for java-names (like methods, classes, variablenames etc)
let s:javaname = '[a-zA-Z_][a-zA-Z0-9_]*'

let s:brackets = '\(s*\([\s*]\s\+\)\=\)'

let s:javaMethodPattern     = '\(^\|\s\+\)' . s:javaname . '\s*(.*)\s*\(throws\|{\|;\|$\)'
let s:javaMethodAntiPattern = '='

let s:commentTagPattern     = '^\s*\*\=\s*@[a-zA-Z]\+\(\s\|$\)'

let s:javaClassPattern	    = '\(^\|\s\)\(class\|interface\)\s\+' . s:javaname . '\({\|\s\|$\)'

" FIXME: this might not be valid:
let s:javaVariablePattern   = '\(\s\|^\)' . s:javaname . s:brackets . '.*\(;\|=.*;\)'

" Should file comments be written?
function! s:IsFileComments() 
  return s:rangeStart <= 1 && s:rangeStart == s:rangeEnd
endfunction

" Executed on a comment-tag?
function! s:IsCommentTag()
  return s:combinedString =~ s:commentTagPattern 
endfunction

" Executed on a method declaration?
function! s:IsMethod()
  let str = s:combinedString

  return str =~ s:javaMethodPattern && str !~ s:javaMethodAntiPattern
endfunction

" Executed on a class declaration?
function! s:IsClass()
  return s:combinedString =~ s:javaClassPattern
endfunction

" Executed on variable declaration?
function! s:IsVariable()
  return s:combinedString =~ s:javaVariablePattern
endfunction

  

" ===================================================
" Utility functions
" ===================================================

function! s:GetIndentation(string)
  return substitute(a:string, '^\(\s*\).*', '\1', '')
endfunction

" returns one string combined from the strings on the given range.
function! s:GetCombinedString(rangeStart, rangeEnd)
  let line 	     = a:rangeStart
  let combinedString = getline(line)

  while line < a:rangeEnd
    let line = line + 1
    let combinedString = combinedString . ' ' . getline(line)
  endwhile

  return combinedString
endfunction

function! s:AppendStars(amount)
  let i = a:amount
  while i > 0
    call s:AppendStr(' * ')
    let i = i - 1
  endwhile
endfunction


function! s:MoveCursorToEOL(line)
  exe "normal " . a:line . "G$"
endfunction

function! s:MoveCursor() 
  if !exists("b:jcommenter_move_cursor")
    return
  endif
  if !b:jcommenter_move_cursor
    return
  endif
  let startInsert = exists("b:jcommenter_autostart_insert_mode") && b:jcommenter_autostart_insert_mode
  if exists("b:jcommenter_description_starts_from_first_line") && b:jcommenter_description_starts_from_first_line
    call s:MoveCursorToEOL(s:rangeStart)
  else
    call s:MoveCursorToEOL(s:rangeStart + 1)
  endif
  if startInsert
    startinsert
  endif
endfunction

let s:appendPos = 1

" A function for appending strings to the buffer.
" First set the 's:appendPos', then call this function repeatedly to append
" strings after that position.
function! s:AppendStr(string)
  call append(s:appendPos, s:indent . a:string)
  let s:appendPos = s:appendPos + 1
  let s:linesAppended = s:linesAppended + 1
endfunction

function! s:Trim(string)
  return substitute(a:string, '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction


